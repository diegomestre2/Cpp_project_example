1. What do we mean by “Programming is understanding”?
Programming is a way to solve a determined problem, therefore understanding the problem is the first step towards the solution.

2. The chapter details the creation of a calculator program. Write a short analysis of what the
calculator should be able to do.
The calculator program should be able to evaluate expressions and give results. The expression is
composed of operator and operands, while also characters to determin the precedence and some options. The program should be able 
to parses the expressions to a set of tokens, which are representations of each character, and evaluate them considering the precedence.

3. How do you break a problem up into smaller manageable parts?
By looking for parts of a solution that can be separatly described and implemented.

4. Why is creating a small, limited version of a program a good idea?
It is a good a idea to create a small version first because it can be easier to specify and implement.
It also gives a starting point to work with and understand the problem a bit more.

5. Why is feature creep a bad idea?
It is easier to build a program in stages than all at once.
By implementing only the essential features the programmers can have a better understanding of the problem.


6. What are the three main phases of software development?
Analysis
Design
Implementation

7. What is a “use case”?
Use case is a sketch or example of use.

8. What is the purpose of testing?
Even after the design and analysis there are usually a few cases that are not entirely covered
by the program. Therefore it is necessary to perform some tests to get some feedback and 
indentify new features.

9. According to the outline in the chapter, describe the difference between a Term, an
Expression, a Number, and a Primary.

Primary: Used to represent primary tokens to be evaluted, for instance numbers and parentheses.

Term: Used to represent the precendence of operations, it gets a primary as left operand and the token right after, in case
of multiplication or division, it requests the next operand to perform the operation and return the intermediate
result to the expression.

Expressions: Used to represent the entire operation. It gets intermediate results from term as a left operand and requests the operator,
in case of sum or subtraction it requests the right operand and performs the operation.

Numbers: Used to represent the operands within the expression. It is a kind of primary.

10. In the chapter, an input was broken down into its component Terms, Expressions, Primarys,
and Numbers. Do this for (17+4)/(5–1).

                                    Expression
                                        |
                                      Term
                _________________________________________________
                |                       |                       |
               Term                     |                       |
                |                       |                       |
             Primary                    |                     Primary
                |                       |                       |
'('         Expression         ')'      |      '('          Expression         ')'
|       _________________       |       |       |       _________________       |
|       |       |       |       |       |       |       |       |       |       |
|    Expression |       |       |       |       |   Expression  |       |       |
|       |       |       |       |       |       |       |       |       |       |
|      Term     |     Term      |       |       |     Term      |     Term      |
|       |       |       |       |       |       |       |       |       |       |
|      Primary  |     Primary   |       |       |     Primary   |     Primary   |
|       |       |       |       |       |       |       |       |       |       |
|      Number   |     Number    |       |       |     Number    |     Number    |
|       |       |       |       |       |       |       |       |       |       |
(       17      +       4       )       /       (       5       -       1       )

11. Why does the program not have a function called number()?
Because Number is already defined as a type of token.

12. What is a token?
A Token is a sequence of characters that has a meaning (kind and/or value) and represents an unit in the expression.

13. What is a grammar? A grammar rule?
A grammar is defined by a syntax and some rules to use that syntax.
A grammar rule is a definition of a sequence of uses of its syntax.

14. What is a class? What do we use classes for?
A class is a keyword that defines a user defined type.
It is used to indicate that a type with zero or more members is being defined.

15. How can we provide a default value for a member of a class?
In order to provide a default value fo a member of a class, it is necessary to 
set the values int initialization list of the default constructor.

16. In the expression function, why is the default for the switch-statement to “put back” the token?
Because the token comes after the expression result, therefore it should be evaluated outside the expression
funtion.

17. What is “look-ahead”?
Is a way to get the next token and decide what we are gonna do with the previous one based on that.

18. What does putback() do and why is it useful?
It includes the given token back to the input stream. It is useful to avoid
that a read token be lost.  

19. Why is the remainder (modulus) operation, %, difficult to implement in the term()?
Because the remainder operation is not defined for floating-point numbers.

20. What do we use the two data members of the Token class for?
The kind member is used to differentiate operands and operations.
Whenever we have an operand the value member stores its value.

21. Why do we (sometimes) split a class’s members into private and public members?
Because public members are part of the interface of the class and can be accessed from any other object that has
an istance of that class. While private members are accessed only internally by its class. Avoiding unsafe accesses.

22. What happens in the Token_stream class when there is a token in the buffer and the get()
function is called?
The function returns the token in the buffer and release the buffer to be used.

23. Why were the ';' and 'q' characters added to the switch-statement in the get() function of the
Token_stream class?
To give support to specific tokens that should be evaluated outside the expression.

24. When should we start testing our program?
Since the beggining and whenever we have a workable part.

25. What is a “user-defined type”? Why would we want one?
Is a specific type defined by the user with the keywords class and struct.
We use this feature because the language cannot support all kind of types.

26. What is the interface to a C++ “user-defined type”?
The functions and data members defined as public within a class or struct.

27. Why do we want to rely on libraries of code?
Because as a programmer we want to avoid complicated solutions and reinventing the wheel.